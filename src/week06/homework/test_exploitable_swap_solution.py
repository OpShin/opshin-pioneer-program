from copy import deepcopy
from functools import cache
from typing import Tuple

import opshin.prelude
import pycardano
from opshin import build

import src.week05
from src.utils import network
from src.utils.mock import MockChainContext, MockUser
from src.week06 import lecture_dir
from src.week06.lecture import exploitable_swap

# build script once outside test function
plutus_script = build(lecture_dir.joinpath("exploitable_swap.py"))
script_hash = pycardano.plutus_script_hash(plutus_script)
script_address = pycardano.Address(script_hash, network=network)


def create_seller_nft(
    context: MockChainContext,
) -> Tuple[MockChainContext, MockUser, pycardano.MultiAsset]:
    user = MockUser(context)
    user.fund(100_000_000)  # 100 ADA

    # get utxo
    utxo_to_spend = None
    for utxo in user.utxos():
        if utxo.output.amount.coin > 3_000_000:
            utxo_to_spend = utxo
            break
    assert utxo_to_spend is not None, "UTxO not found to spend!"

    # create nft to sell
    token_name = "opshin_is_the_best"
    script_path = src.week05.lecture_dir.joinpath("nft.py")
    oref = opshin.prelude.TxOutRef(
        id=opshin.prelude.TxId(bytes(utxo_to_spend.input.transaction_id)),
        idx=utxo_to_spend.input.index,
    )
    tn_bytes = bytes(token_name, encoding="utf-8")
    plutus_script = build(script_path, oref, tn_bytes)

    # Build the transaction
    builder = pycardano.TransactionBuilder(context)
    builder.add_minting_script(script=plutus_script, redeemer=pycardano.Redeemer(0))
    nft = pycardano.MultiAsset.from_primitive(
        {bytes(pycardano.plutus_script_hash(plutus_script)): {tn_bytes: 1}}
    )
    builder.mint = nft
    builder.add_input(utxo_to_spend)
    builder.add_output(
        pycardano.TransactionOutput(
            user.address,
            amount=pycardano.Value(
                coin=context.protocol_param.min_utxo, multi_asset=builder.mint
            ),
        )
    )

    # Sign the transaction
    signed_tx = builder.build_and_sign(
        signing_keys=[user.signing_key],
        change_address=user.address,
    )

    # Submit the transaction
    context.submit_tx(signed_tx)

    return context, user, nft


def lock_nft(
    context: MockChainContext, seller: MockUser, nft: pycardano.MultiAsset, price: int
) -> MockChainContext:
    # create datum
    datum = exploitable_swap.DatumSwap(seller.verification_key.payload, price)

    # user 1 locks 2 ADA ("val") in validator
    val = pycardano.Value(multi_asset=nft)
    tx_builder = pycardano.TransactionBuilder(context)
    tx_builder.add_input_address(seller.address)
    tx_builder.add_output(
        pycardano.TransactionOutput(script_address, amount=val, datum=datum)
    )
    tx = tx_builder.build_and_sign([seller.signing_key], change_address=seller.address)
    context.submit_tx(tx)
    return context


def create_buyer(context) -> Tuple[MockChainContext, MockUser]:
    buyer = MockUser(context)
    buyer.fund(100_000_000)
    return context, buyer


def unlock_nft(
    context: MockChainContext, buyer: MockUser, seller: MockUser, price: int
):
    utxo = context.utxos(script_address)[0]
    tx_builder = pycardano.TransactionBuilder(context)
    tx_builder.add_input_address(buyer.address)
    tx_builder.add_script_input(
        utxo,
        redeemer=pycardano.Redeemer(0),
        script=plutus_script,
    )
    tx_builder.add_output(
        pycardano.TransactionOutput(seller.address, pycardano.Value(coin=price))
    )
    tx_builder.validity_start = context.last_block_slot
    tx_builder.ttl = tx_builder.validity_start + 1
    tx = tx_builder.build_and_sign([seller.signing_key], change_address=seller.address)
    context.submit_tx(tx)
    return context


@cache
def setup_context():
    context = MockChainContext()
    context.opshin_scripts[plutus_script] = exploitable_swap.validator

    # run the minting contract to create the seller's nft
    context, seller, nft = create_seller_nft(context)
    return context, seller, nft


def test_run():
    context, seller, nft = deepcopy(setup_context())

    # wait for a bit
    context.wait(1000)

    # seller locks nft for 5 ADA
    price = 5_000_000
    context = lock_nft(context, seller, nft, price)

    # wait for a bit
    context.wait(1000)

    # create the buyer
    context, buyer = create_buyer(context)

    # buyer attempts to unlock nft by paying 5 ADA to seller
    unlock_nft(context, buyer, seller, price)

    # check that buyer has the nft
    buyer_has_nft = False
    for utxo in buyer.utxos():
        if utxo.output.amount.multi_asset:
            assert utxo.output.amount.multi_asset == nft
            buyer_has_nft = True
    assert buyer_has_nft


if __name__ == "__main__":
    test_run()
